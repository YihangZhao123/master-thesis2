package template.nonRTOS.fifo.circular.A;

import forsyde.io.java.core.Vertex;
import generator.generator;
import java.util.function.Consumer;
import java.util.function.Predicate;
import org.eclipse.xtend2.lib.StringConcatenation;
import template.Template;
import utils.Global;
import utils.Name;
import utils.Query;
import utils.Save;

@SuppressWarnings("all")
public class channelSrc implements Template {
  public channelSrc() {
  }
  
  public void create() {
    final Predicate<Vertex> _function = new Predicate<Vertex>() {
      public boolean test(final Vertex v) {
        return (v.hasTrait("impl::TokenizableDataBlock")).booleanValue();
      }
    };
    final Consumer<Vertex> _function_1 = new Consumer<Vertex>() {
      public void accept(final Vertex v) {
        Save.save(channelSrc.this.srcPath(v), channelSrc.this.src(v));
      }
    };
    Global.model.vertexSet().stream().filter(_function).forEach(_function_1);
  }
  
  public String src(final Vertex vertex) {
    String _xblockexpression = null;
    {
      String name = vertex.getIdentifier();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("#include \"../inc/sdfchannel_");
      String _replace = name.replace("/", "_");
      _builder.append(_replace);
      _builder.append(".h\"");
      _builder.newLineIfNotEmpty();
      _builder.append("#include <stdio.h>");
      _builder.newLine();
      _builder.append("volatile spinlock spinlock_");
      _builder.append(name);
      _builder.append("={.flag=0};");
      _builder.newLineIfNotEmpty();
      long buffersize = Query.getBufferSize(vertex);
      _builder.newLineIfNotEmpty();
      _builder.append("unsigned long buffersize_");
      _builder.append(name);
      _builder.append(" = ");
      _builder.append((buffersize + 1));
      _builder.append(";");
      _builder.newLineIfNotEmpty();
      _builder.append("volatile token_");
      _builder.append(name);
      _builder.append(" arr_");
      _builder.append(name);
      _builder.append("[");
      _builder.append((buffersize + 1));
      _builder.append("];");
      _builder.newLineIfNotEmpty();
      _builder.append("circularFIFO_");
      _builder.append(name);
      _builder.append(" channel_");
      _builder.append(name);
      _builder.append(";");
      _builder.newLineIfNotEmpty();
      _builder.newLine();
      _builder.append("void init_circularFIFO_");
      _builder.append(name);
      _builder.append("(circularFIFO_");
      _builder.append(name);
      _builder.append("* channel ,token_");
      _builder.append(name);
      _builder.append("* buffer,size_t size){");
      _builder.newLineIfNotEmpty();
      _builder.append("\t\t  ");
      _builder.newLine();
      _builder.append("\t\t    ");
      _builder.append("channel->buffer = buffer;");
      _builder.newLine();
      _builder.append("\t\t    ");
      _builder.append("channel->size=size;");
      _builder.newLine();
      _builder.append("\t\t    ");
      _builder.append("channel->front = 0;");
      _builder.newLine();
      _builder.append("\t\t    ");
      _builder.append("channel->rear = 0;\t\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("/* ");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("read a token from channel.");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("src: is channel ");
      _builder.append(name, "\t");
      _builder.newLineIfNotEmpty();
      _builder.append("\t");
      _builder.append("dst:data");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("*/");
      _builder.newLine();
      _builder.append("inline int read_circularFIFO_non_blocking_");
      _builder.append(name);
      _builder.append("(circularFIFO_");
      _builder.append(name);
      _builder.append("* channel, token_");
      _builder.append(name);
      _builder.append("* data){");
      _builder.newLineIfNotEmpty();
      _builder.append("\t\t");
      _builder.append("if(channel->front==channel->rear){");
      _builder.newLine();
      _builder.append("\t\t    \t");
      _builder.append("//empty ");
      _builder.newLine();
      _builder.append("\t\t    \t");
      _builder.append("return -1;");
      _builder.newLine();
      _builder.append("\t\t    \t\t\t");
      _builder.newLine();
      _builder.append("\t\t   ");
      _builder.append("}else{");
      _builder.newLine();
      _builder.append("\t\t    \t");
      _builder.append("*data = channel->buffer[channel->front];");
      _builder.newLine();
      _builder.append("\t\t    \t");
      _builder.append("//printf(\"buffer ");
      _builder.append(name, "\t\t    \t");
      _builder.append(": before read, front: %d, rear %d size:%d\\n\",channel->front,channel->rear,channel->size);");
      _builder.newLineIfNotEmpty();
      _builder.append("\t\t    \t");
      _builder.append("channel->front= (channel->front+1)%channel->size;");
      _builder.newLine();
      _builder.append("\t\t    \t");
      _builder.append("//printf(\"buffer ");
      _builder.append(name, "\t\t    \t");
      _builder.append(": after read, front: %d, rear %d size:%d\\n\",channel->front,channel->rear,channel->size);");
      _builder.newLineIfNotEmpty();
      _builder.append("\t\t    \t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t\t    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("/*");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("write a token to _circular ");
      _builder.append(name, "\t\t");
      _builder.append(".");
      _builder.newLineIfNotEmpty();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("*/");
      _builder.newLine();
      _builder.append("inline int write_circularFIFO_non_blocking_");
      _builder.append(name);
      _builder.append("(circularFIFO_");
      _builder.append(name);
      _builder.append("* channel, token_");
      _builder.append(name);
      _builder.append(" value){");
      _builder.newLineIfNotEmpty();
      _builder.append("\t    ");
      _builder.append("/*if the buffer is full*/");
      _builder.newLine();
      _builder.append("\t    ");
      _builder.append("if((channel->rear+1)%channel->size == channel->front){");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("//full!");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("//discard the data");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("//printf(\"buffer full error\\n!\");");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("return -1;");
      _builder.newLine();
      _builder.append("\t     ");
      _builder.append("}else{");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("channel->buffer[channel->rear] = value;");
      _builder.newLine();
      _builder.append("\t       ");
      _builder.append("//printf(\"buffer ");
      _builder.append(name, "\t       ");
      _builder.append(":before write, front: %d, rear %d size:%d\\n\",channel->front,channel->rear,channel->size);");
      _builder.newLineIfNotEmpty();
      _builder.append("\t        ");
      _builder.append("channel->rear= (channel->rear+1)%channel->size;");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("//printf(\"buffer ");
      _builder.append(name, "\t        ");
      _builder.append(":after write, front: %d, rear %d size:%d\\n\",channel->front,channel->rear,channel->size);");
      _builder.newLineIfNotEmpty();
      _builder.append("\t        ");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t    ");
      _builder.append("}\t\t\t");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("inline\tint read_circularFIFO_blocking_");
      _builder.append(name);
      _builder.append("(circularFIFO_");
      _builder.append(name);
      _builder.append("* channel, token_");
      _builder.append(name);
      _builder.append("* data,spinlock* lock){");
      _builder.newLineIfNotEmpty();
      _builder.append("\t\t");
      _builder.append("spinlock_get(lock);");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if(channel->front==channel->rear){");
      _builder.newLine();
      _builder.append("\t\t    \t");
      _builder.append("//empty ");
      _builder.newLine();
      _builder.append("\t\t    \t");
      _builder.append("spinlock_release(lock);");
      _builder.newLine();
      _builder.append("\t\t    \t");
      _builder.append("return -1;");
      _builder.newLine();
      _builder.append("\t\t    \t\t\t");
      _builder.newLine();
      _builder.append("\t\t   ");
      _builder.append("}else{");
      _builder.newLine();
      _builder.append("\t\t    \t");
      _builder.append("*data = channel->buffer[channel->front];");
      _builder.newLine();
      _builder.append("\t\t    \t");
      _builder.append("//printf(\"buffer ");
      _builder.append(name, "\t\t    \t");
      _builder.append(": before read, front: %d, rear %d size:%d\\n\",channel->front,channel->rear,channel->size);");
      _builder.newLineIfNotEmpty();
      _builder.append("\t\t    \t");
      _builder.append("channel->front= (channel->front+1)%channel->size;");
      _builder.newLine();
      _builder.append("\t\t    \t");
      _builder.append("//printf(\"buffer ");
      _builder.append(name, "\t\t    \t");
      _builder.append(": after read, front: %d, rear %d size:%d\\n\",channel->front,channel->rear,channel->size);");
      _builder.newLineIfNotEmpty();
      _builder.append("\t\t    \t");
      _builder.append("spinlock_release(lock);");
      _builder.newLine();
      _builder.append("\t\t    \t");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t\t    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("inline int write_circularFIFO_blocking_");
      _builder.append(name);
      _builder.append("(circularFIFO_");
      _builder.append(name);
      _builder.append("* channel, token_");
      _builder.append(name);
      _builder.append(" value,spinlock* lock){");
      _builder.newLineIfNotEmpty();
      _builder.append("\t");
      _builder.append("spinlock_get(lock);");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t   ");
      _builder.append("/*if the buffer is full*/");
      _builder.newLine();
      _builder.append("\t   ");
      _builder.append("if((channel->rear+1)%channel->size == channel->front){");
      _builder.newLine();
      _builder.append("\t       ");
      _builder.append("//full!");
      _builder.newLine();
      _builder.append("\t       ");
      _builder.append("//discard the data");
      _builder.newLine();
      _builder.append("\t       ");
      _builder.append("//printf(\"buffer full error\\n!\");");
      _builder.newLine();
      _builder.append("\t       ");
      _builder.append("spinlock_release(lock);");
      _builder.newLine();
      _builder.append("\t       ");
      _builder.append("return -1;");
      _builder.newLine();
      _builder.append("\t    ");
      _builder.append("}else{");
      _builder.newLine();
      _builder.append("\t       ");
      _builder.append("channel->buffer[channel->rear] = value;");
      _builder.newLine();
      _builder.append("\t      ");
      _builder.append("//printf(\"buffer ");
      _builder.append(name, "\t      ");
      _builder.append(":before write, front: %d, rear %d size:%d\\n\",channel->front,channel->rear,channel->size);");
      _builder.newLineIfNotEmpty();
      _builder.append("\t       ");
      _builder.append("channel->rear= (channel->rear+1)%channel->size;");
      _builder.newLine();
      _builder.append("\t       ");
      _builder.append("//printf(\"buffer ");
      _builder.append(name, "\t       ");
      _builder.append(":after write, front: %d, rear %d size:%d\\n\",channel->front,channel->rear,channel->size);");
      _builder.newLineIfNotEmpty();
      _builder.append("\t       ");
      _builder.append("spinlock_release(lock);");
      _builder.newLine();
      _builder.append("\t       ");
      _builder.append("return 0;");
      _builder.newLine();
      _builder.append("\t   ");
      _builder.append("}\t\t\t\t");
      _builder.newLine();
      _builder.append("}\t\t\t");
      _builder.newLine();
      _xblockexpression = _builder.toString();
    }
    return _xblockexpression;
  }
  
  private String srcPath(final Vertex vertex) {
    String _name = Name.name(vertex);
    String _plus = ((generator.root + "/src/sdfchannel_") + _name);
    return (_plus + ".c");
  }
}
